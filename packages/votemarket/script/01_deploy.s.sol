// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.19;

import {Script, console, VmSafe} from "@forge-std/src/Script.sol";
import {Oracle} from "src/oracle/Oracle.sol";
import {VerifierV2} from "src/verifiers/VerifierV2.sol";
import {OracleLens} from "src/oracle/OracleLens.sol";
import {Votemarket} from "src/Votemarket.sol";
import {ICreate3Factory} from "src/interfaces/ICreate3Factory.sol";
import {SafeCastLib} from "@solady/src/utils/SafeCastLib.sol";

/// @notice A library that contains all the addresses needed by this script
/// @dev • How to add a new gauge controller:
///         - add the address of the new gauge controller in this library
///         - update the `VoteMarketDeploy._getGaugeController()` function with a new case
library AddressBook {
    // All the gauge controllers supported by this script
    address internal constant CURVE_GAUGE_CONTROLLER = 0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB;
    address internal constant BALANCER_GAUGE_CONTROLLER = 0xC128468b7Ce63eA702C1f104D55A2566b13D3ABD;
    address internal constant FXN_GAUGE_CONTROLLER = 0xe60eB8098B34eD775ac44B1ddE864e098C6d7f37;

    // All the utility addresses needed by this script
    address internal constant GOVERNANCE = 0xB0552b6860CE5C0202976Db056b5e3Cc4f9CC765;
    address internal constant CREATE3_FACTORY = 0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed;
}

/// @notice A library that contains all the contract identifiers required to generate the salt for each deterministic deployment.
/// @dev The salt is used for deterministic deployment. It follows this template: `STAKEDAO.VOTEMARKET.{gaugeOwner}.{seed}.{contractIdentifier}`
///      - The `{gaugeOwner}` is the name of the protocol who controls the gauges. It can be any value included in `VoteMarketDeploy.chains`.
///      - The `{seed}` is a random bytes8 automatically generated by the script. It is generated once at the construction time.
///        It is the same for all the deployments across all chains.
///      - The `{contractIdentifier}` is the identifier of the contract to deploy. It can be "ORACLE", "VERIFIER", "ORACLE_LENS" or "VOTEMARKET".
///        The same contract is deployed using the same `{contractIdentifier}` on all chains, leading to the same contract address on all chains.
///
///      The salt prefix (`STAKEDAO.VOTEMARKET.{gaugeOwner}.{seed}.`) is constant for all the deployments accross the chain.
///      Only the `{contractIdentifier}` is different for each contract, but the same contract is deployed using the same
///      `{contractIdentifier}` on all chains, leading to the same contract address on all chains.
///      This pattern is used to ensure that the deployment is deterministic and can be reproduced exactly the same way on all chains.
library ContractIdentifier {
    string internal constant ORACLE = "ORACLE";
    string internal constant VERIFIER = "VERIFIER";
    string internal constant ORACLE_LENS = "ORACLE_LENS";
    string internal constant VOTEMARKET = "VOTEMARKET";
}

/// @dev • How to add a new chain:
///         - ensure the rpc_endpoints are defined in the `foundry.toml` file
///         - add the chain name to the `chains` array
///
///      • How to run the script using an account stored in the keystore:
///         `MIN_PERIODS=<value> EPOCH_LENGTH=<value>  LAST_USER_VOTE_SLOT=<value>  \
///         USER_SLOPE_SLOT=<value>  WEIGHT_SLOT=<value>  forge script VoteMarketDeploy \
///         --account <account_name> [--broadcast]`
///
///      • How to run the script using a ledger account:
///      `MIN_PERIODS=<value> EPOCH_LENGTH=<value>  LAST_USER_VOTE_SLOT=<value>  \
///      USER_SLOPE_SLOT=<value>  WEIGHT_SLOT=<value>  forge script VoteMarketDeploy \
///      --ledger --account-index <account_index> [--broadcast]`
///
///      • How to run the script locally for testing purposes:
///         - Run 4 instances of ANVIL, one for each chain.
///             - `anvil --fork-url <rpc_arbitrum> --fork-chain-id 42161 --port 8545`
///             - `anvil --fork-url <rpc_optimism> --fork-chain-id 10 --port 8546`
///             - `anvil --fork-url <rpc_base> --fork-chain-id 137 --port 8547`
///             - `anvil --fork-url <rpc_polygon> --fork-chain-id 8453 --port 8548`
///         - Run the script with the following command.
///         `MIN_PERIODS=25 EPOCH_LENGTH=1000 LAST_USER_VOTE_SLOT=10000 \
///         USER_SLOPE_SLOT=10000 WEIGHT_SLOT=10000 forge script VoteMarketDeploy \
///          --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
///          --broadcast`
contract VoteMarketDeploy is Script {
    ICreate3Factory internal constant create3Factory = ICreate3Factory(AddressBook.CREATE3_FACTORY);

    /// @notice The seed used to generate the salt for the deterministic deployment of the protocol.
    /// @dev This seed is the same for all the deployments across all chains. It is generated once at the construction time.
    bytes8 internal immutable RANDOM_SEED;

    /// @notice The list of chains on which the protocol will be deployed.
    string[] internal chains = ["arbitrum", "optimism", "base", "polygon"];

    /// @notice The list of deployed protocols.
    DeployedProtocol[] internal deployedProtocols;

    /// @notice The protocol configuration parameters.
    /// @param epochLength The length of an epoch in seconds. Passed to the `Votemarket` constructor.
    /// @param lastUserVoteSlot The storage slot of the last user vote mapping. Passed to the `Verifier` constructor.
    /// @param userSlopeSlot The storage slot of the user slope mapping. Passed to the `Verifier` constructor.
    /// @param weightSlot The storage slot of the weight mapping. Passed to the `Verifier` constructor.
    /// @param minPeriods The minimum number of periods for a campaign. Passed to the `Votemarket` constructor.
    /// @param gaugeController The address of the gauge controller. Passed to the `Verifier` constructor.
    /// @param name The name of the owner of the gauge controller. Can be any value included in `chains`.
    struct Protocol {
        uint256 epochLength;
        uint256 lastUserVoteSlot;
        uint256 userSlopeSlot;
        uint256 weightSlot;
        uint8 minPeriods;
        address gaugeController;
        string name;
    }

    /// @notice The data of the deployed protocol on a given chain.
    /// @param platform The address of the deployed `Votemarket` contract.
    /// @param chainId The chain ID when the protocol was deployed.
    struct DeployedProtocol {
        address platform;
        string protocol;
        uint256 chainId;
    }

    constructor() {
        // Generate a random seed for the deterministic deployment of the protocol
        RANDOM_SEED = bytes8(uint64(vm.randomUint()));

        // Label the create3 factory address for developer-friendly logging
        vm.label(AddressBook.CREATE3_FACTORY, "CREATE3_FACTORY");
    }

    /// @notice Get the correct gauge controller address for the given protocol name
    /// @dev The parameter `name` is expected to be in uppercase.
    /// @param name The name of the owner of the gauge controller. Can be any value included in `chains`.
    /// @return _ The address of the gauge controller.
    /// @custom:throws InvalidProtocolName if the given protocol name is not supported
    function _getGaugeController(string memory name) internal returns (address) {
        bytes32 nameHash = keccak256(abi.encodePacked(name));

        if (nameHash == keccak256(abi.encodePacked("CURVE"))) {
            vm.label(AddressBook.CURVE_GAUGE_CONTROLLER, "CURVE_GAUGE_CONTROLLER");
            return AddressBook.CURVE_GAUGE_CONTROLLER;
        } else if (nameHash == keccak256(abi.encodePacked("BALANCER"))) {
            vm.label(AddressBook.BALANCER_GAUGE_CONTROLLER, "BALANCER_GAUGE_CONTROLLER");
            return AddressBook.BALANCER_GAUGE_CONTROLLER;
        } else if (nameHash == keccak256(abi.encodePacked("FXN"))) {
            vm.label(AddressBook.FXN_GAUGE_CONTROLLER, "FXN_GAUGE_CONTROLLER");
            return AddressBook.FXN_GAUGE_CONTROLLER;
        } else {
            revert("InvalidProtocolName");
        }
    }

    /// @notice Assert that the deployment is deterministic.
    function _assertDeterministicDeployment() private view {
        for (uint256 i = 1; i < deployedProtocols.length; i++) {
            require(
                deployedProtocols[i].platform == deployedProtocols[i - 1].platform, "Broken deterministic deployment"
            );
        }
    }

    /// @notice Log the deployment data for all the chains.
    function _logDeployments() private view {
        for (uint256 i; i < deployedProtocols.length; i++) {
            console.log("Deploy on %s at %s", vm.toUppercase(chains[i]), vm.toString(deployedProtocols[i].platform));
            console.log("--------------------------------");
        }
    }

    /// @notice Log a reminder to the developer to accept the governance role of the oracle on all the chains.
    function _logReminderGovernance() private view {
        address platform = deployedProtocols[0].platform;
        // Get the address of the oracle contract stored in the oracle lens contract associated with the votemarket contract
        address oracleContract = OracleLens(Votemarket(payable(platform)).ORACLE()).oracle();

        console.log(
            string.concat(
                "\n The governance of the Oracle contract (%s) \n has been transfered to "
                "the DAO governance address (%s). \n Do not forget we MUST ACCEPT, on all "
                "the chains, the governance role of the oracle \n by calling `acceptGovernance()`!"
            ),
            oracleContract,
            AddressBook.GOVERNANCE
        );
    }

    /// @notice Get the salt for the deterministic deployment of a specific contract.
    /// @param prefix The constant prefix of the salt shared by all the deployments of the protocol.
    /// @param contractIdentifier The identifier of the contract to deploy. Can be any value included in `ContractIdentifier`.
    /// @return _ The salt for a specific contract.
    function _getSalt(string memory prefix, string memory contractIdentifier) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(prefix, contractIdentifier));
    }

    /// @notice Update the database with the new deployed protocols.
    /// @dev This modifier is used to update the database with the new deployed protocols. It is a post-hook attached
    ///      to the `run()` function. It is called only if the script runs well and is executed in broadcast mode.
    /// @custom:throws DatabaseUpdateFailed if the `update-votemarket.js` script fails to update the database
    modifier postHook_updateDataBase() {
        _;

        // If the script is executed in broadcast mode, update the database
        if (vm.isContext(VmSafe.ForgeContext.ScriptBroadcast)) {
            // Concatenate the chain IDs into a single string separated by commas
            string memory chainIds;
            for (uint256 i; i < deployedProtocols.length; i++) {
                string memory separator = i == deployedProtocols.length - 1 ? "" : ",";
                chainIds = string.concat(chainIds, vm.toString(deployedProtocols[i].chainId), separator);
            }

            // inputs = `node data/update-votemarket.js <protocol> <platform> <chainIds> <seed>`
            string[] memory inputs = new string[](6);
            inputs[0] = "node";
            inputs[1] = "data/update-votemarket.js";
            inputs[2] = deployedProtocols[0].protocol;
            inputs[3] = vm.toString(deployedProtocols[0].platform);
            inputs[4] = string.concat("[", chainIds, "]"); // Convert the chain IDs array to a valid JSON array string
            inputs[5] = vm.toString(abi.encodePacked(RANDOM_SEED));

            // 0xAA is the valid expected output of the update-votemarket.js script. If the script fails, it will revert.
            require(bytes32(vm.ffi(inputs)) == bytes32(hex"AA"), "DatabaseUpdateFailed");
        }
    }

    /// @notice Deploy the protocol on one chain.
    /// @param protocol The protocol configuration parameters.
    /// @param saltPrefix The constant prefix of the salt shared by all the deployments of the protocol.
    /// @return platform The address of the deployed `Votemarket` contract.
    function _deploy(Protocol memory protocol, string memory saltPrefix) internal returns (address platform) {
        vm.startBroadcast();

        // -- DEPLOY THE ORACLE CONTRACT
        bytes32 salt = _getSalt(saltPrefix, ContractIdentifier.ORACLE);
        bytes memory initCode = abi.encodePacked(type(Oracle).creationCode, abi.encode(msg.sender));
        address oracle = create3Factory.deployCreate3(salt, initCode);

        // -- DEPLOY THE VERIFIER CONTRACT
        salt = _getSalt(saltPrefix, ContractIdentifier.VERIFIER);
        initCode = abi.encodePacked(
            type(VerifierV2).creationCode,
            abi.encode(
                oracle, protocol.gaugeController, protocol.lastUserVoteSlot, protocol.userSlopeSlot, protocol.weightSlot
            )
        );
        address verifier = create3Factory.deployCreate3(salt, initCode);

        // -- DEPLOY THE ORACLE LENS CONTRACT
        salt = _getSalt(saltPrefix, ContractIdentifier.ORACLE_LENS);
        initCode = abi.encodePacked(type(OracleLens).creationCode, abi.encode(oracle));
        address oracleLens = create3Factory.deployCreate3(salt, initCode);

        // -- DEPLOY THE VOTEMARKET CONTRACT
        salt = _getSalt(saltPrefix, ContractIdentifier.VOTEMARKET);
        initCode = abi.encodePacked(
            type(Votemarket).creationCode,
            abi.encode(
                AddressBook.GOVERNANCE, // governance contract
                oracleLens,
                AddressBook.GOVERNANCE, // fee collector contract
                protocol.epochLength,
                protocol.minPeriods
            )
        );
        platform = create3Factory.deployCreate3(salt, initCode);

        // Set the verifier as the authorized data provider for the oracle
        Oracle(payable(oracle)).setAuthorizedDataProvider(verifier);
        // Transfer the governance role of the oracle to the governance contract
        Oracle(payable(oracle)).transferGovernance(AddressBook.GOVERNANCE);

        vm.stopBroadcast();
    }

    /// @notice Run the entire deployment process on all the defined chains.
    /// @return saltPrefix The constant prefix of the salt shared by all the deployments of the protocol.
    ///         Reusing the same salt prefix on a new chain will redeploy the same protocol on the new chain.
    /// @custom:throws Overflow if the given `minPeriods` env variable is greater than 255
    /// @custom:throws InvalidProtocolName if the given protocol name is not supported
    function run() external postHook_updateDataBase returns (string memory saltPrefix) {
        Protocol memory protocol;

        // Load the required environment variables
        protocol.epochLength = vm.envUint("EPOCH_LENGTH");
        protocol.lastUserVoteSlot = vm.envUint("LAST_USER_VOTE_SLOT");
        protocol.userSlopeSlot = vm.envUint("USER_SLOPE_SLOT");
        protocol.weightSlot = vm.envUint("WEIGHT_SLOT");
        // Load the `minPeriods` env variable. Revert if the given value is greater than 255 (uint8 max value)
        protocol.minPeriods = SafeCastLib.toUint8(vm.envUint("MIN_PERIODS"));
        // Prompt the user to enter the protocol name.
        protocol.name = vm.toUppercase(vm.prompt("Enter the protocol name: (CURVE, BALANCER or FXN)"));
        // Load the optional `seed` env variable. If not provided, use the random seed generated at the construction time.
        // @dev: This env variable is not really intended to be used in production. Only use it for testing purposes,
        //       or for deploying already deployed protocols on a new chain. To do so, set the `SEED` env variable to the
        //       same value as the one stored in the database.
        bytes8 seed = bytes8(vm.envOr("SEED", RANDOM_SEED));

        // Get the correct gauge controller address for the given protocol name. Revert if the given protocol name is not supported.
        protocol.gaugeController = _getGaugeController(protocol.name);
        // Generate the constant prefix that will be part of the deterministic deployment salt. This prefix is the same for all the deployments across all chains.
        saltPrefix = string.concat("STAKEDAO.VOTEMARKET.", protocol.name, ".", vm.toString(abi.encodePacked(seed)), ".");

        // Deploy the protocol on all the authorized chains and store the deployment data
        for (uint256 i; i < chains.length; i++) {
            vm.createSelectFork(vm.rpcUrl(chains[i]));
            address platform = _deploy(protocol, saltPrefix);

            // Store the deployed protocol data
            deployedProtocols.push(
                DeployedProtocol({platform: platform, protocol: protocol.name, chainId: block.chainid})
            );
        }

        // Assert that the deployment is deterministic
        _assertDeterministicDeployment();

        // Extra log for the developer
        _logDeployments();
        _logReminderGovernance();
    }
}
